---
title: "Prep_LinearityMeasure"
author: "Pauliina Vuorinen"
date: "19/04/2022-27/06/2022"
output: html_document
library: "~/Extra/RPackages.bib"
---

## Introduction and Definition of Nonlinearity

The purpose of this script is to compute a measure of linearity during reading of the short story. 

Linear navigation was defined as movement forwards in the text without skipping any pages. Nonlinear navigation, on the other hand, was defined as a regression or a forward leap according to the following:

* Regression: Any navigation backwards in the text, either by turning the pages or by using the progress bar.
* Forward leap: A jump forwards in the text with the progress bar to a section further than the next page, or turning of more than one page in a row at a browsing speed.

Browsing was used in the definition of nonlinearity because the intention behind browsing is to move between locations in the text rather than read. Browsing speed was defined as less than one second used on a page-view. One second would not be enough time to read the text on a page, but it would only allow participants to get a gist of the information.

To measure frequency of nonlinear navigation, we calculate how often a nonnavigation event is initiated. A nonlinear is initiated if a nonlinear event occurs following a linear navigation event, or a nonlinear event to a different direction (e.g. forward leap following a regression) or executed via a different method (e.g. a regression by using the progress bar following a regression by turning pages backwards). Simply put, previous event's (k-1) linearity, method of nonlinear navigation or direction of nonlinear navigation, does not correspond with the current event's (k) linearity, method or direction of nonlinear navigation, and the current event is nonlinear. This measure therefore reflects the frequency of initiating nonlinear navigation during reading of the story.

Frequency of initiating nonlinearity was used as a measure of linearity of reading instead of linearity categories (linear or nonnavigation, regression, or forward leap) to make sure that each navigation event is only counted once. Using the linearity category would inflate the amount of nonlinear navigation if it is used across multiple pages (e.g. a regression that includes the participant going multiple pages backwards by page turns). 

This script uses a dataframe that was wrangled in Prep_TrackingDataWrangling.Rmd.

The working directory is not changed with setwd() because this script is knit remotely in other scripts.

```{r 'configure-path'}
if (exists("ExternalAnalysisFilePath")) {
    # ExternalAnalysisFilePath: ~/Short_Story_Reading_Behaviour_Public/
    mypath_SSRB <- ExternalAnalysisFilePath
} else if (grepl("Prep", getwd())) {
    mypath_SSRB <- dirname(getwd())
} else if (grepl("Short_Story_Reading_Behaviour_Public", getwd())) {
    mypath_SSRB <- getwd()
} else {
    # get working directory manually
    mypath_SSRB <- paste0(
            dirname(getwd()),
            "/Short_Story_Reading_Behaviour_Public"
        )
}
```

## Setup

```{r, setup}
library(tidyverse)
library(tidyr)
library(dplyr)
library(plotly) # interactive plots
getwd() # working directory should be ~/Short_Story_Reading_Behaviour_Public
```

## Load data and check variable types

To determine linearity, we use grouped_tracking_data that was created in Prep_TrackingDataWrangling.Rmd

```{r 'load data'}
grouped_tracking_data <-
    read.csv(
        paste0(
            mypath_SSRB,
            "/Data/wrangled_grouped_tracking_data.csv"
        ),
        header = TRUE,
        sep = ";",
        dec = ","
    )
grouped_tracking_data <- dplyr::select(grouped_tracking_data, -X, -X.1)
```

```{r 'change variable types'}
str(grouped_tracking_data)
source(
    paste0(
        mypath_SSRB,
        "/Functions/Functions_VariableTypeConversion.R"
    )
)

## turn user and story indicators into factors
grouped_tracking_data[, c(
    "UserId",
    "StoryId"
)] <- convert.magic(
    grouped_tracking_data[, c(
        "UserId",
        "StoryId"
    )],
    "factor"
)
## turn reading block (page view) number,
### reading session number, and
#### navigation block number into ordered factors
grouped_tracking_data[, c(
    "ReadingBlockNumber",
    "ReadingSessionNumber",
    "NavigationBlockNumber"
)] <- convert.magic(
    grouped_tracking_data[, c(
        "ReadingBlockNumber",
        "ReadingSessionNumber",
        "NavigationBlockNumber"
    )],
    "ordered"
)
## fix date and time variable types
grouped_tracking_data$Date <-
    as.Date(
        grouped_tracking_data$Date,
        format = "%Y-%m-%d"
    )
TempTimeObject <- strsplit(grouped_tracking_data$Time, " ")
TempTimeObject <- sapply(TempTimeObject, "[[", 2)
grouped_tracking_data$TempTimeObject <- TempTimeObject
grouped_tracking_data <- dplyr::select(grouped_tracking_data, -Time)
names(grouped_tracking_data)[which(colnames(grouped_tracking_data) == "TempTimeObject")] <- "Time"
grouped_tracking_data$DateTime <- paste(
    grouped_tracking_data$Date,
    grouped_tracking_data$Time
)
op <-
    options(digits.secs = 3)
grouped_tracking_data$Time <-
    strptime(
        grouped_tracking_data$Time,
        format = "%H:%M:%OS"
    )
grouped_tracking_data <- grouped_tracking_data %>%
    mutate(DateTime = as.POSIXct(DateTime, format = "%Y-%m-%d %H:%M:%OS"))
```

```{r 'order df'}
# order the df by User, date, and time
grouped_tracking_data <-
    grouped_tracking_data[
        with(
            grouped_tracking_data,
            order(UserId, Date, Time)
        ),
    ]
```

## Determine linearity

Next we determine how much the participants' location shifts in between different navigation blocks. This essentially tells us how much, and to what direction, the participant moved in the text (if at all).

To count the number of pages turned, we first create variables that check whether consecutive navigation blocks (one per row) should be compared. We only want to compare navigation blocks from
a) the same user
b) the same reading session and
c) the same reading set up (see below).

A reading set up affects the amount of 'pages' that the short story has, for example, in a small browser window the story is organised in more 'pages' than in a large browser window. Pages turned should only be determined between events that have the same reading set up. Note that this does not limit our ability to notice linearity of navigation as changing the reading set up will either result in an event that is in its own navigation block (which can then be compared to a subsequent navigation block; this happens e.g. when the participant resizes a browser window), or a change in reading set up starts a new reading session (e.g. when the participant changes device).

First, we create texts that will be useful in determining linearity:

```{r 'create tests'}
grouped_tracking_data$IsNewUser <-
    (
        grouped_tracking_data$UserId !=
            (lag(grouped_tracking_data$UserId, 1))
    )
grouped_tracking_data$IsNewSession <-
    (
        grouped_tracking_data$ReadingSessionNumber !=
            (lag(grouped_tracking_data$ReadingSessionNumber, 1))
    )
grouped_tracking_data$IsReadingSetUpChange <-
    (
        grouped_tracking_data$NBFirstPagesInSection !=
            (lag(grouped_tracking_data$NBFirstPagesInSection, 1))
    )
# first event is TRUE for all 3 tests
grouped_tracking_data[1, "IsNewUser"] <- TRUE
grouped_tracking_data[1, "IsNewSession"] <- TRUE
grouped_tracking_data[1, "IsReadingSetUpChange"] <- TRUE
```

We can then calculate the amount of 'pages' turned between navigation blocks. The variable is calculated by subtracting a navigation block's start location (in pages) from the next navigation block's start location. If the reading set up, user, or reading session changes between the two navigation blocks and the navigation block includes movement, 'PagesTurned' is instead calculated by comparing the first page in a navigation block to the last page in the same navigation block.

```{r 'count pages turned'}
# count the number of pages turned within a navigation block
grouped_tracking_data$PagesTurned <-
    ifelse(
        ( # following navigation block is from
            ## same user,
            ## same reading session, and
            ## same reading set up
            !lead(grouped_tracking_data$IsNewUser, 1) &
                !lead(grouped_tracking_data$IsNewSession, 1) &
                !lead(grouped_tracking_data$IsReadingSetUpChange, 1)
        ),
        (
            lead(grouped_tracking_data$NBFirstPage, 1) -
                grouped_tracking_data$NBFirstPage
        ),
        ifelse(
            ( # the navigation block includes movement but
                ## the navigation block following it has a
                ### different user,
                ### different reading session, or
                ### different reading set up
                grouped_tracking_data$NBFirstPage !=
                    grouped_tracking_data$NBLastPage
            ),
            (
                grouped_tracking_data$NBLastPage -
                    grouped_tracking_data$NBFirstPage
            ),
            # the navigation block doesn't include movement
            0
        )
    )
# Manually set value for PagesTurned on last row of data
LastRow <- nrow(grouped_tracking_data)
grouped_tracking_data[LastRow, "PagesTurned"] <- (
    grouped_tracking_data[LastRow, "NBLastPage"] -
        grouped_tracking_data[LastRow, "NBFirstPage"]
)
# Check PagesTurned
## - regression, + forward leap or a chronological page turn, 0 not navigation
table(
    sign(grouped_tracking_data$PagesTurned)
)
```

PagesTurned tells us the direction and extent of navigation. We use this information to assign each navigation event a label of 'Regression' or 'ForwardLeap'.

Considering that regressions refer to any movement backwards in text, any navigation block with a negative value for PagesTurned can be labelled as a 'Regression' (PagesTurned < 0). Forward leaps include forward movement to a position further than the next page (PagesTurned > 1), either by turning pages at a browsing speed (NavigationBlockSpeedLabel == "Browsing") or by using the progress bar (Type == progressBarJump).

```{r 'regression and forward leap label assignment'}
grouped_tracking_data$IsRegression <-
    (
        grouped_tracking_data$PagesTurned < 0
    )
table(grouped_tracking_data$IsRegression)

grouped_tracking_data$IsForwardLeap <-
    (
        ((grouped_tracking_data$PagesTurned > 1) &
            (grouped_tracking_data$NBSpeedLabel == "Browsing")) |
            ((grouped_tracking_data$PagesTurned > 1) &
                (grouped_tracking_data$NBAnyProgressBarUsage))
    )
table(grouped_tracking_data$IsForwardLeap)
```

The data includes `r sum(grouped_tracking_data$IsRegression)` regressions and `r sum(grouped_tracking_data$IsForwardLeap)` forward leaps.

Our aim is to measure linearity on each page-view, and so we need to merge grouped_tracking_data with wrangled_tracking_data. First, we load in wrangled_tracking_data:

```{r 'load wrangled tracking data'}
tracking_data <-
    read.csv(
        paste0(
            mypath_SSRB,
            "/Data/wrangled_tracking_data.csv"
        ),
        header = TRUE,
        sep = ";",
        dec = ","
    )
tracking_data <- dplyr::select(tracking_data, -X, -X.1)
```

```{r 'fix variable types'}
## turn user and story indicators into factors
tracking_data[, c(
    "UserId",
    "StoryId"
)] <- convert.magic(
    tracking_data[, c(
        "UserId",
        "StoryId"
    )],
    "factor"
)
## turn reading block (page view) number,
### reading session number, and
#### navigation block number into ordered factors
tracking_data[, c(
    "ReadingBlockNumber",
    "ReadingSessionNumber",
    "NavigationBlockNumber"
)] <- convert.magic(
    tracking_data[, c(
        "ReadingBlockNumber",
        "ReadingSessionNumber",
        "NavigationBlockNumber"
    )],
    "ordered"
)
## fix date and time variable types
tracking_data$Date <-
    as.Date(
        tracking_data$Date,
        format = "%Y-%m-%d"
    )
TempTimeObject <- strsplit(tracking_data$Time, " ")
TempTimeObject <- sapply(TempTimeObject, "[[", 2)
tracking_data$TempTimeObject <- TempTimeObject
tracking_data <- dplyr::select(tracking_data, -Time)
names(tracking_data)[which(colnames(tracking_data) == "TempTimeObject")] <- "Time"
tracking_data$DateTime <- paste(
    tracking_data$Date,
    tracking_data$Time
)
op <-
    options(digits.secs = 3)
tracking_data$Time <-
    strptime(
        tracking_data$Time,
        format = "%H:%M:%OS"
    )
tracking_data <- tracking_data %>%
    mutate(DateTime = as.POSIXct(DateTime, format = "%Y-%m-%d %H:%M:%OS"))
```

Merge the dataframes together:

```{r 'merge navigation block data with tracking data'}
# columns selected from grouped_tracking_data:
## UserId, NavigationBlockNumber, ReadingSessionNumber
### IsRegression, IsForwardLeap, PagesTurned,
### NBFirstCumulativeRSTime, NBLastCumulativeRSTime, NBSpeedLabel
# Identify these columns first
column_UserId <- which(colnames(grouped_tracking_data) == "UserId")
column_NBNumber <- which(colnames(grouped_tracking_data) == "NavigationBlockNumber")
column_RSNumber <- which(colnames(grouped_tracking_data) == "ReadingSessionNumber")
column_IsRegression <- which(colnames(grouped_tracking_data) == "IsRegression")
column_IsForwardLeap <- which(colnames(grouped_tracking_data) == "IsForwardLeap")
column_PagesTurned <- which(colnames(grouped_tracking_data) == "PagesTurned")
column_NBFirstCumulativeRSTime <- which(colnames(grouped_tracking_data) == "NBFirstCumulativeRSTime")
column_NBLastCumulativeRSTime <- which(colnames(grouped_tracking_data) == "NBLastCumulativeRSTime")
column_NBSpeedLabel <- which(colnames(grouped_tracking_data) == "NBSpeedLabel")

# Merge dfs:
tracking_data <-
    merge(
        tracking_data,
        grouped_tracking_data[, c(
            column_UserId,
            column_NBNumber,
            column_RSNumber,
            column_IsRegression,
            column_IsForwardLeap,
            column_PagesTurned,
            column_NBFirstCumulativeRSTime,
            column_NBLastCumulativeRSTime,
            column_NBSpeedLabel
        )],
        by = c("UserId", "ReadingSessionNumber", "NavigationBlockNumber"),
        all.x = TRUE
    )
```

Next, we create columns that summarise information on nonlinearity based on IsRegression and IsForwardLeap
(1) IsNonlinearNavigation tells us whether the event includes a regression or a forward leap
(2) Linearity tells us what is the type of linearity (regression, forward leap, or linear/nonnavigation)
(3) StartsNonlinearity tells us whether the event initiates nonlinear navigation following linear navigation, nonnavigation, or nonlinear navigation of a different type.

Calculate (1) IsNonlinearNavigation:

```{r}
tracking_data$IsNonlinearNavigation <-
    ifelse(
        (tracking_data$IsRegression |
            tracking_data$IsForwardLeap),
        TRUE,
        FALSE
    )
```

```{r}
table(tracking_data$IsNonlinearNavigation)
```

`r sum(tracking_data$IsNonlinearNavigation)` of the `r nrow(tracking_data)` events include nonlinear navigation of the text (`r round((sum(tracking_data$IsNonlinearNavigation)/nrow(tracking_data))*100, 2)`%). 

Usage of nonlinear navigation varies between participants:
```{r}
table(tracking_data$IsNonlinearNavigation, tracking_data$UserId)
ggplot(tracking_data, aes(x = IsNonlinearNavigation, group = UserId, fill = UserId)) +
    geom_bar(position = position_dodge(), stat = "count") +
    theme_classic()
```

Indeed, the plot indicates that some participants use nonlinearity quite often whereas others use it very rarely.

Calculate (2) Linearity:

```{r}
tracking_data$Linearity <-
    ifelse(
        tracking_data$IsRegression,
        "Regression",
        ifelse(
            tracking_data$IsForwardLeap,
            "ForwardLeap",
            "LinearOrNonNavigation"
        )
    )
```

```{r}
table(tracking_data$Linearity)
```

Of the `r sum(tracking_data$IsNonlinearNavigation)` nonlinear navigation events, `r sum(tracking_data$Linearity == "Regression")` are regressions (`r round((sum(tracking_data$Linearity == "Regression")/sum(tracking_data$IsNonlinearNavigation))*100, 2)`%), and the remaining `r sum(tracking_data$Linearity == "ForwardLeap")` are forward leaps (`r round((sum(tracking_data$Linearity == "ForwardLeap")/sum(tracking_data$IsNonlinearNavigation))*100, 2)`%).

Usage of the different linearity types again varies between participants:
```{r}
table(tracking_data$Linearity, tracking_data$UserId)
```

Note that the amount of events is connected to participants' device size, and so users' event counts are not directly comparable.

To calculate (3) StartsNonlinearity we first order tracking_data and create tests:

```{r 'order tracking_data'}
# order the df by User, date, time, and Id
tracking_data <-
    tracking_data[
        with(
            tracking_data,
            order(UserId, Date, Time, Id)
        ),
    ]
```

```{r}
tracking_data$IsNewUser <-
    (
        tracking_data$UserId !=
            (lag(tracking_data$UserId, 1))
    )
tracking_data$IsNewSession <-
    (
        tracking_data$ReadingSessionNumber !=
            (lag(tracking_data$ReadingSessionNumber, 1))
    )
tracking_data$IsReadingSetUpChange <-
    (
        tracking_data$TotalPagesInSection !=
            (lag(tracking_data$TotalPagesInSection, 1))
    )
# first event is TRUE for all 3 tests
tracking_data[1, "IsNewUser"] <- TRUE
tracking_data[1, "IsNewSession"] <- TRUE
tracking_data[1, "IsReadingSetUpChange"] <- TRUE
```

Then, use tests in calculating StartsNonlinearity:

```{r}
## Find events that initiate nonlinearity
for (row in 1:nrow(tracking_data)) {
    if (row == 1 |
        tracking_data[row, "IsNewUser"] |
        tracking_data[row, "IsNewSession"] |
        tracking_data[row, "IsReadingSetUpChange"]) {
        # first row, new user, new session, or new set up
        if (tracking_data[row, "IsNonlinearNavigation"]) {
            # nonlinear navigation
            tracking_data[row, "StartsNonlinearity"] <-
                TRUE
        } else {
            # not nonlinear
            tracking_data[row, "StartsNonlinearity"] <-
                FALSE
        }
    } else {
        # same user, reading session and reading set up
        if ((tracking_data[row - 1, "Linearity"] !=
            tracking_data[row, "Linearity"]) &
            tracking_data[row, "IsNonlinearNavigation"]) {
            # linearity type changes between previous and current event
            ## and current event is nonlinear
            tracking_data[row, "StartsNonlinearity"] <-
                TRUE
        } else {
            # the nonlinear event doesn't start nonlinearity
            tracking_data[row, "StartsNonlinearity"] <-
                FALSE
        }
    }
}
```

```{r}
table(tracking_data$StartsNonlinearity)
```

Out of all events, `r sum(tracking_data$StartsNonlinearity)` iniate nonlinearity (`r round((sum(tracking_data$StartsNonlinearity)/nrow(tracking_data))*100, 2)`%).

```{r}
table(tracking_data$StartsNonlinearity, tracking_data$UserId)
```

StartsNonlinearity also varies between participants. This measure is not connected to participants' number of events and so we can compare it between participants.

Create a summary dataframe to compare participants in their linearity:

```{r}
participant_navigation_counts <- tracking_data %>%
    group_by(UserId) %>%
    summarise(
        StartsNonlinearityCount = sum(StartsNonlinearity),
        IsNonlinearNavigationCount = sum(IsNonlinearNavigation),
        IsRegressionCount = sum(IsRegression),
        IsForwardLeapCount = sum(IsForwardLeap),
        EventCount = n()
    )
```

```{r}
StaticPlot <- ggplot(
    participant_navigation_counts,
    aes(x = IsNonlinearNavigationCount, y = StartsNonlinearityCount, colour = UserId)
) +
    geom_point() +
    theme_classic()
ggplotly(StaticPlot)
```

IsNonlinearNavigation and StartsNonlinearity are strongly correlated when there are only few nonlinear navigation events. This indicates that the nonlinear events are likely to be separate from each other, instead of being used for a longer period at once (consecutive nonlinearity or not). For example, participant id 55 has 18 nonlinear navigation events and 9 of them initiate nonlinearity. This indicates that on average, participant id 55 used two nonlinear navigation events concurrently (18/9=2). 

However, this connection is less apparent for the participants who have more nonlinear events. For example, participant id 7 has 136 nonlinear navigation events but only 18 initiating events, indicating that on average, the participant used 8 nonlinear events after one initiating nonlinear event. In contrast, participant id 51 used nonlinear navigation 110 times and initiated nonlinearity 35 times, making their average count of nonlinear events per an initiated nonlinearity 3.

Finally, to create a measure for linearity to use in the analysis, we filter the dataframe to only include one event per page-view. We therefore remove events that occur outside of visible page-views, such as disengagements and dialog events (triggered by viewing of information sheet). We then select one event per page-view that includes information on linearity (in particular, "StartsNonlinearity")

```{r, create a linearity df with one event per page-view}
# Remove events that do not occur on a page-view
## 8144 rows (full data 8774 rows)
linearity_measure_data <- tracking_data %>%
    filter(
        Engagement != "Disengagement" &
            Engagement != "Dialog"
    )
# make sure the df is correctly ordered
tracking_data <-
    tracking_data[
        with(
            tracking_data,
            order(UserId, Date, Time, Id)
        ),
    ]
# Select one event per each page-view:
## group events by
### UserId, ReadingSessionNumber, ReadingBlockNumber (page-view indicator), and Condition
#### and summarise other important variables into columns
linearity_measure_data <- linearity_measure_data %>%
    group_by(UserId, StoryId, ReadingSessionNumber, ReadingBlockNumber, Condition) %>%
    summarise(
        StartLocation = first(StartLocation),
        EndLocation = first(EndLocation),
        IsNewUser = any(IsNewUser),
        IsNewSession = any(IsNewSession),
        IsReadingSetUpChange = any(IsReadingSetUpChange),
        IncludesNonlinearity = any(IsNonlinearNavigation),
        StartsNonlinearity = any(StartsNonlinearity),
        FirstTimeUntilDeadlineDays = first(TimeBeforeDeadlinesDays),
        FirstCumulativeRSTime = first(CumulativeRSTime),
        WindowWidth = first(WindowWidth)
    )
```

## Save linearity measure df

The new df is saved for usage in analysis.
The dataset has already been saved, and so the below sr code chunk is not run.

```{r, eval=FALSE, echo=TRUE}
# write.csv2(
#     linearity_measure_data,
#     "linearity_measure_data.csv"
# )
```