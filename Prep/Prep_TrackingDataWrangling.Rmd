---
title: "Prep_TrackingDataWrangling"
author: "Pauliina Vuorinen"
date: "18/03/2022-"
output: html_document
library: "~/Extra/RPackages.bib"
---

## Introduction

The purpose of this script is to clean the raw reading behaviour tracking data for analysis.

## Setup

Load libraries, set working directory

```{r 'setup'}
library(psych)
library(tidyverse)
library(tidyr)
library(dplyr)
```

The path should point to the main folder in this repository ('Short_Story_Reading_Behaviour_Public'). Make sure that is the case by configuring the path here:

```{r 'configure-path'}
getwd() # this should be ~Short_Story_Reading_Behaviour_Public
# if the path is incorrect, configure it here:
# setwd()
```

## Load data and check variable types

Load raw data from Data -folder and change variable types. See documents in Info -folder for information on different tracking events.

The raw tracking dataset has 10,390 tracking events from 62 participants (before exclusions).

```{r 'load-data'}
raw_tracking_data <-
    read.csv(
        "Data/preprocessed_raw_tracking_data.csv",
        header = TRUE,
        sep = ";",
        dec = ","
    )
head(raw_tracking_data)
nrow(raw_tracking_data)
length(unique(raw_tracking_data$UserId))
```

```{r 'change-variable-types'}
str(raw_tracking_data)
names(raw_tracking_data)[names(raw_tracking_data) == "BookId"] <- "StoryId"
source("Functions/Functions_VariableTypeConversion.R")

## turn columns into factors that should be factors
raw_tracking_data[, c(
    "UserId",
    "StoryId",
    "Engagement",
    "EngagedSpeedLabel",
    "Direction",
    "NavigationBlockDirection"
)] <- convert.magic(
    raw_tracking_data[, c(
        "UserId",
        "StoryId",
        "Engagement",
        "EngagedSpeedLabel",
        "Direction",
        "NavigationBlockDirection"
    )],
    "factor"
)
## fix numeric columns that were automatically categorised as character
raw_tracking_data[, c(
    "BaselineSpeed",
    "AdjustedBaselineSpeed",
    "TimeBeforeDeadlinesDays",
    "TimeBeforeDeadlineMinutes",
    "DurationMinutes",
    "ReadingBlockDuration",
    "EngagedReadingDuration",
    "EngagedReadingSpeed",
    "NavigationBlockDuration"
)] <- convert.magic(
    raw_tracking_data[, c(
        "BaselineSpeed",
        "AdjustedBaselineSpeed",
        "TimeBeforeDeadlinesDays",
        "TimeBeforeDeadlineMinutes",
        "DurationMinutes",
        "ReadingBlockDuration",
        "EngagedReadingDuration",
        "EngagedReadingSpeed",
        "NavigationBlockDuration"
    )],
    "numeric"
)
## turn 'isIntrinsicCondition' into a logical variable
raw_tracking_data$IsIntrinsicCondition <-
    as.logical(
        raw_tracking_data$IsIntrinsicCondition
    )
### Create variable called 'Condition'
raw_tracking_data$Condition <-
    ifelse(raw_tracking_data$IsIntrinsicCondition == TRUE,
        "AutonomousCondition",
        "NonAutonomousCondition"
    )
## fix date and time variable types
raw_tracking_data$Date <-
    as.Date(
        raw_tracking_data$Date,
        format = "%d.%m.%Y"
    )
raw_tracking_data$Time <-
    gsub(
        x = raw_tracking_data$Time, ",", "."
    )
op <-
    options(digits.secs = 3)
raw_tracking_data$Time <-
    strptime(
        raw_tracking_data$Time,
        format = "%H:%M:%OS"
    )
```

```{r 'order-df'}
# order by User, date, time and event id
raw_tracking_data <-
    raw_tracking_data[
        with(
            raw_tracking_data,
            order(UserId, Date, Time, Id)
        ),
    ]
```

All events that have been tracked outside the e-reader (IsReading == FALSE) are removed. The e-reader tracks some usage of the website landing page in order to determine when participants leave the e-reader. However, these events are not useful for the analysis and so they are removed:

```{r 'remove-events-outside-e-reader'}
raw_tracking_data <- filter(
    raw_tracking_data,
    IsReading != FALSE
)
```

Removing the !IsReading events reduces the amount of events from 10,390 to `r nrow(raw_tracking_data)`

## Exclusion criteria

Sixty-two participants were recruited to take part in the study. Two of the participants did not finish the study, and so they are excluded from the sample. The final *n* = 60.

```{r 'exclusion'}
raw_tracking_data <-
    filter(
        raw_tracking_data,
        (UserId != "33") &
        (UserId != "61")
    )
```

## Missing and erroneous data values

Fix unrealistic and misleading values in the tracking data. These errors arise from accidental miscoding during the collection of the tracking data, or alternative data formatting.

1. Reading block numbers (page views) were recorded as zero when the participant was not viewing a page. This is misleading, and so zeros are turned to NAs.

```{r 'fix-reading-block-formatting'}
raw_tracking_data[, "ReadingBlockNumber"][raw_tracking_data[, "ReadingBlockNumber"] == 0] <- NA
```

2. Inactive timeout events are erroneously coded as 'engagements' in the raw data. The inactive timeout indicates that the page view has been masked due to > 5mins of inactivity, and therefore, these event types should be coded as 'disengagements'.

```{r 'fix-inactiveTimeout-engagement-type'}
raw_tracking_data[raw_tracking_data$Type == "inactiveTimeout", ]$Engagement <- "Disengagement"
```

### Adjustments to event and navigation block durations

Event durations are important not only because they can tell us about how long an event lasted, but 'DurationMinutes' is also used to create cumulative durations (such as 'EngagementDuration'). The event durations are calculated by deducting an event's start time from the following event's start time. Therefore, the durations of events in the middle and the beginning of a reading session are accurate as long as all events are present in the tracking data. The last event in a reading session, however, has an excessive duration because it is miscalculated by comparing the event to the next one that is in a new reading session. This excessive duration is adjusted in two different ways, depending on whether the event is categorised as a 'disengagement' or an 'engagement'.

```{r 'find-last-event-in-reading-session'}
# make sure the df is correctly ordered
raw_tracking_data <-
    raw_tracking_data[
        with(
            raw_tracking_data,
            order(UserId, Date, Time, Id)
        ),
    ]
# an event is the last one in a reading session if:
## the current session != next, or the current user != next
raw_tracking_data$IsLastEventInReadingSession <-
    (
        (raw_tracking_data$ReadingSessionNumber !=
            lead(raw_tracking_data$ReadingSessionNumber, 1)) |
            (raw_tracking_data$UserId !=
                lead(raw_tracking_data$UserId, 1))
    )
# last event in df assigned manually
raw_tracking_data$IsLastEventInReadingSession <-
    replace_na(raw_tracking_data$IsLastEventInReadingSession, TRUE)
```

117 of the last reading session events are disengagements and five are engagements:

```{r 'check-last-event-in-reading-session-engagement-types'}
table(
    raw_tracking_data$Engagement,
    raw_tracking_data$IsLastEventInReadingSession
)
```

**Disengagements.** If the last event in a reading session is a disengagement, such as 'close' or 'logout' (see more information on event types in Info folder), the duration of the event is recorded as 0. This is because a disengagement at the end of a reading session indicates of the participants' intention to leave the e-reader system, and so its duration is arbitrary.

**Engagements.** Engagements that have a duration of >5min indicate of a missing tracking event. This can happen for a couple different reasons:

* A reading session ending in an 'engagement' indicates that the final disengagement event (triggered by the closure of the e-reader system, for example, event of type 'logout') is missing.
* In the middle of a reading session, an engagement event that has a duration of >5min is also indicative of a missing event: if an engagement event lasts for longer than 5 minutes, the data is missing a 'blur' and an 'inactiveTimeout' event from the tracking data. This is because the e-reader system automatically masks the text after 5 minutes of inactivity which triggers the 'blur' and 'inactiveTimeout' events.

Missing events occur when the system doesn't have the time to record an event, for example, when the e-reader system is abruptly closed or when network connection fails. The tracking works on the client side, but no temporary data storage is implemented to store events collected and so these events are lost.

Correctly recorded engagements should last for a maximum of 5 minutes before the e-reader system masks the text. Therefore, excessive engagement durations are checked by filtering the dataset for engagements that last for longer than 5.1 minutes to allow a slow delay in the mask appearing.

```{r 'find-excessive-engagement-durations'}
excessive_engagement_durations_subdata <-
    filter(
        raw_tracking_data,
        (Engagement == "Engagement") &
            (DurationMinutes > 5.1)
    )
nrow(excessive_engagement_durations_subdata)
# only 3 cases of excessive engagement duration
```

The excessive durations are adjusted by creating new variables:
1. 'AdjustedEventDuration' shows the suggested new event duration
    * Set to 5 minutes for engagement events and to 0 for non-engagement events.
    * If an event is not the last event in a reading session or an excessive engagement duration, the event duration does not need to be adjusted and so AdjustedEventDuration = DurationMinutes

```{r 'adjustments-to-event-durations'}
for (row in 1:nrow(raw_tracking_data)) {
    if (raw_tracking_data[row, "Engagement"] == "Engagement" &
        raw_tracking_data[row, "DurationMinutes"] > 5.1) {
        # excessive engagement duration
        raw_tracking_data[row, "AdjustedEventDuration"] <- 5
        raw_tracking_data[row, "IsAdjustedDuration"] <- TRUE
    } else if (raw_tracking_data[row, "Engagement"] != "Engagement" &
        raw_tracking_data[row, "IsLastEventInReadingSession"]) {
        # excessive non-engagement duration
        raw_tracking_data[row, "AdjustedEventDuration"] <- 0
        raw_tracking_data[row, "IsAdjustedDuration"] <- TRUE
    } else {
        raw_tracking_data[row, "AdjustedEventDuration"] <-
            raw_tracking_data[row, "DurationMinutes"]
        raw_tracking_data[row, "IsAdjustedDuration"] <- FALSE
    }
}
```

```{r 'check-AdjustedEventDuration-1/2'}
table(
    raw_tracking_data$IsAdjustedDuration,
    raw_tracking_data$Engagement
)
```

`r sum(raw_tracking_data$IsAdjustedDuration)` event durations were adjusted.

Next:

2. 'AdjustedNavigationBlockDuration' shows the suggested adjustment to NavigationBlockDuration
    * NavigationBlockDuration sums together the durations of all events that belong in the same navigation block (events that include navigation in the same direction at roughly the same speed)
    * NavigationBlockDuration is therefore influenced by the error in event durations. We adjust navigation block duration by summing AdjustedEventDuration for each UserId and each NavigationBlockNumber

```{r 'adjust-navigation-block-durations'}
adjusted_navigationblock_duration <- raw_tracking_data %>%
    group_by(UserId, NavigationBlockNumber) %>%
    summarise(
        AdjustedNavigationBlockDuration =
            sum(AdjustedEventDuration)
    )
raw_tracking_data <-
    merge(
        raw_tracking_data,
        adjusted_navigationblock_duration,
        by = c("UserId", "NavigationBlockNumber")
    )
```

Finally, we create a new dataframe without unadjusted event duration and navigation block duration to avoid confusion. 'AdjustedEventDuration' and 'AdjustedNavigationBlockDuration' are then renamed to 'DurationMinutes' and 'NavigationBlockDuration' for simplicity.

```{r 'remove-unadjusted-durations'}
adjusted_durations_data <- raw_tracking_data %>%
    select(-DurationMinutes, -NavigationBlockDuration)
names(adjusted_durations_data)[names(adjusted_durations_data) == "AdjustedEventDuration"] <- "DurationMinutes"
names(adjusted_durations_data)[names(adjusted_durations_data) == "AdjustedNavigationBlockDuration"] <- "NavigationBlockDuration"
```

## Adjust engagement type

Each event is given an engagement type that reflects how participants are using the e-reader at a time. Engagements can be divided in four groups:

(1) Disengagement: the participant is not using the e-reader or the text is not visible.
(2) Dialog: the participant is using the menus or reading information sheets.
(3) Engagement: the participant is engaged in using the e-reader, the text is visible and the e-reader is active.
(4) DisruptedEngagement: the participant is engaged in using the e-reader, but only for 15 seconds or less continuously. The participant may have opened the e-reader by accident, or they may not be ready to resume the reading activity. The threshold of 15s is used in accordance to a study by @Iqbal2007 who used >15 seconds as an indicator of resumed engagement in the primary activity in a work engagement study.

The raw data includes a variable called 'Engagement' which tells us about the engagement category of each event. However, DisruptedEngagements are not differentiated from Engagements in the raw data. Therefore, the 'Engagement' column is adjusted.

In order to do this, we need to determine how long each engagement type lasts continuously. Participants may have multiple events of the same engagement type consecutively, and to check whether an engagement is longer than 15 seconds, these events need to be grouped together and calculated a continuous duration. We call this 'continuous engagement duration' (or occassionally, CED for short).

First, we create a new dataframe to record detail on which events have the same engagement type:

```{r 'create-CED-dataset'}
CED_id_data <- data.frame(
    adjusted_durations_data$UserId,
    adjusted_durations_data$ReadingSessionNumber,
    adjusted_durations_data$Engagement,
    adjusted_durations_data$Id
)
CED_id_data[, "EngagementTypeId"] <- 0
names(CED_id_data)[1] <- "UserId"
names(CED_id_data)[2] <- "ReadingSessionNumber"
names(CED_id_data)[3] <- "Engagement"
names(CED_id_data)[4] <- "Id"
CED_id_data <- CED_id_data[0, ]
CED_id_data$EngagementTypeId <- as.numeric(CED_id_data$EngagementTypeId)
```

Second, check that adjusted_durations_data is correctly ordered:

```{r}
# order by User, date, time and event id
adjusted_durations_data <-
    adjusted_durations_data[
        with(
            raw_tracking_data,
            order(UserId, Date, Time, Id)
        ),
    ]
```

Third, record 'EngagementTypeId' by looping through all events and checking if the current and previous event have the same engagement type:

```{r 'create-EngagementTypeId'}
# 'y' for the current row in the data
## used to e.g. save to a correct row in CED_id_data
y <- 1

for (user in levels(adjusted_durations_data$UserId)) {
    EventsByUser <- subset(
        x = adjusted_durations_data,
        subset = UserId == user
    )
    EventsByUser$ReadingSessionNumber <-
        as.ordered(EventsByUser$ReadingSessionNumber)
    for (readingsession in levels(EventsByUser$ReadingSessionNumber)) {
        EventsByUserInASession <- subset(
            x = EventsByUser,
            subset = ReadingSessionNumber == readingsession
        )
        x <- 1 # x is used to calculate EngagementTypeId

        for (row in 1:nrow(EventsByUserInASession)) {
            if (row == 1) { # first event in reading session, id = x
                CED_id_data[y, "EngagementTypeId"] <- x
            } else if (EventsByUserInASession[row, "Engagement"] == EventsByUserInASession[row - 1, "Engagement"]) { # same engagement type, id = x
                CED_id_data[y, "EngagementTypeId"] <- x
            } else if (EventsByUserInASession[row, "Engagement"] != EventsByUserInASession[row - 1, "Engagement"]) { # different engagement type, id = x+1
                x <- x + 1
                CED_id_data[y, "EngagementTypeId"] <- x
            } else {
                # unforeseen events:
                x <- x + 1
                CED_id_data[y, "EngagementTypeId"] <- "CHECK"
            }
            CED_id_data[y, "UserId"] <- user
            CED_id_data[y, "Engagement"] <- EventsByUserInASession[row, "Engagement"]
            CED_id_data[y, "ReadingSessionNumber"] <- readingsession
            CED_id_data[y, "Id"] <- EventsByUserInASession[row, "Id"]
            y <- y + 1
        }
    }
    print((round(((y / nrow(adjusted_durations_data)) * 100), 2)))
    # the loop prints % done
}
```

Check if the loop had any unforeseen cases:

```{r}
any(CED_id_data$EngagementTypeId == "CHECK")
```

The loop worked well (in addition to automatic checks like this, all calculations have been manually checked).

Next, we merge the CED_id_data with adjusted_durations_data:

```{r 'merge-CED_id_data-with-adjusted_durations_data'}
adjusted_durations_data <- merge(
    adjusted_durations_data,
    CED_id_data,
    by = c(
        "UserId",
        "ReadingSessionNumber",
        "Id",
        "Engagement"
    )
)
```

We can then calculate continuous durations into a new dataframe, and then merge them with adjusted_durations_data:

```{r 'calculate-CED'}
CED_data <- adjusted_durations_data %>%
    group_by(UserId, EngagementTypeId, Engagement, ReadingSessionNumber) %>%
    summarise(
        ContinuousEngagementMinutes = sum(DurationMinutes)
    ) %>%
    mutate(
        ContinuousEngagementSeconds = (ContinuousEngagementMinutes * 60)
    )
adjusted_durations_data <- merge(
    adjusted_durations_data,
    CED_data,
    by = c(
        "UserId",
        "EngagementTypeId",
        "Engagement",
        "ReadingSessionNumber"
    )
)
```

Now that we have information on each continuous engagement category's duration, we can use the durations to re-categorise events' engagement types.
If `(Engagement == Engagement) & (ContinuousEngagementSeconds <= 15)`, the event is categorised as 'DisruptedEngagement' rather than an 'Engagement'. Else, the engagement category remains the same.

```{r 'identify-disrupted-engagements'}
adjusted_durations_data$AdjustedEngagement <- NA
adjusted_durations_data$Engagement <- as.character(adjusted_durations_data$Engagement)

for (row in 1:nrow(adjusted_durations_data)) {
    if ((adjusted_durations_data[row, ]$ContinuousEngagementSeconds <= 15) &
        (adjusted_durations_data[row, ]$Engagement == "Engagement")) {
        adjusted_durations_data[row, ]$AdjustedEngagement <- "DisruptedEngagement"
    } else {
        adjusted_durations_data[row, "AdjustedEngagement"] <- adjusted_durations_data[row, "Engagement"]
    }
    print((round(((row / nrow(adjusted_durations_data)) * 100), 2)))
    # the loop prints % done
}
```

Check AdjustedEngagement and how it is different from Engagement:

```{r}
any(is.na(adjusted_durations_data$AdjustedEngagement))
table(adjusted_durations_data$AdjustedEngagement, adjusted_durations_data$Engagement)
```

In total, `r sum(adjusted_durations_data$AdjustedEngagement == "DisruptedEngagement")` engagements were re-categorised as disrupted engagements.

We then remove the original engagement category value from the data to reduce mistakes. For simplicity, we rename the AdjustedEngagement variable as 'Engagement':

```{r}
adjusted_durations_data <- dplyr::select(
    adjusted_durations_data,
    -Engagement
)
names(adjusted_durations_data)[which(colnames(adjusted_durations_data) == "AdjustedEngagement")] <- "Engagement"
```

### Reading session artefacts

The data analysis for the current study is focused on engaged reading, and so very short reading sessions or sessions that only consist of disengagement events were not considered to be meaningful. Reading sessions with little reading may have occurred when participants attempted to resume a reading session but became quickly distracted by other things, or if they accidentally opened the browser tab in which the e-reader was open.

We expected intentional reading sessions to be captured by the following criteria:

1. Reading sessions should last more than a minute,
2. Less than 95% of the reading session duration should be disengagement events,
3. Less than 85% of the reading session duration should be disengagement and dialog events

To ensure that these thresholds was meaningful and did not remove any reading sessions of interest, we compared the identified session artefacts to visualisations of participants' reading session timelines. See Fig_UserTimelinesWithArtefacts.pdf in Fig folder for reading session timelines with information on which artefacts were identified.

Comparison to the visualisations indicated that these three criteria were sufficient in detecting reading session artefacts.

Create a new df for saving information about reading sessions:

```{r 'create-dataset-for-detail-on-readingsessions'}
UserList <- levels(adjusted_durations_data$UserId)
reading_session_details <- data.frame(
    UserId = factor(),
    ReadingSessionNumber = numeric(),
    SessionLength = numeric(),
    DisengagementDuration = numeric(),
    DialogDuration = numeric(),
    DisruptedEngagementDuration = numeric(),
    EngagementProportion = numeric(),
    DisengagementProportion = numeric(),
    DialogAndDisengagementProportion = numeric()
)
```

```{r 'calculate-detail-on-readingsessions-to-identify-artefacts'}
firstrow <- 1
adjusted_durations_data$ReadingSessionNumber <-
    as.numeric(
        as.character(
            adjusted_durations_data$ReadingSessionNumber
        )
    )

# calculate session details
for (user in UserList) {
    subset_user <- filter(adjusted_durations_data, UserId == user)
    for (session in unique(subset_user$ReadingSessionNumber)) {
        subset_readingsession <- filter(subset_user, ReadingSessionNumber == session)
        temporary_df <- subset_readingsession %>%
            summarise(
                SessionLength =
                    sum(DurationMinutes, na.rm = TRUE),
                DisengagementDuration =
                    sum(
                        subset_readingsession[subset_readingsession$Engagement == "Disengagement", ]$DurationMinutes,
                        na.rm = TRUE
                    ),
                DialogDuration =
                    sum(
                        subset_readingsession[subset_readingsession$Engagement == "Dialog", ]$DurationMinutes,
                        na.rm = TRUE
                    ),
                DisruptedEngagementDuration =
                    sum(
                        subset_readingsession[subset_readingsession$Engagement == "DisruptedEngagement", ]$DurationMinutes,
                        na.rm = TRUE
                    ),
                EngagementProportion =
                    (
                        sum(
                            subset_readingsession[subset_readingsession$Engagement == "Engagement", ]$DurationMinutes,
                            na.rm = TRUE
                        )
                        / SessionLength
                    )
            ) %>%
            mutate(
                DisengagementProportion =
                    (DisengagementDuration / SessionLength),
                DialogAndDisengagementProportion =
                    ((DisengagementDuration + DialogDuration) / SessionLength)
            )
        temporary_df$UserId <- user
        temporary_df$ReadingSessionNumber <- session
        rowscompleted <- nrow(temporary_df)
        reading_session_details <- bind_rows(reading_session_details, temporary_df)
        firstrow <- firstrow + rowscompleted
    }
}
```

```{r}
hist(reading_session_details$EngagementProportion, breaks = 100)
```

Some of the participants' reading sessions are very short, and therefore they are likely to be artefacts.
We identify these potential reading session artefacts on the three criteria:

```{r 'identify-artefacts'}
reading_session_details$PotentialReadingSessionArtefact <-
    ifelse(
        ((reading_session_details$SessionLength < 1) | # criteria 2
            (reading_session_details$DisengagementProportion > 0.95) | # criteria 1
            (reading_session_details$DialogAndDisengagementProportion > 0.85)), # criteria 3
        TRUE,
        FALSE
    )
```

Information about reading sessions is saved for usage in the manuscript. This code is not run a the dataframe has already been saved, and it can found in the 'Data' folder.

```{r 'save-reading-session-details'}
# write.csv2(
#      reading_session_details,
#      "reading_session_details.csv")
```

We then create a new dataframe to inspect which sessions were flagged as artefacts.

```{r 'check-artefacts'}
reading_session_artefacts <-
    filter(
        reading_session_details,
        PotentialReadingSessionArtefact
    )
nrow(reading_session_artefacts)
table(reading_session_artefacts$UserId)
```

In total `r nrow(reading_session_artefacts)` reading sessions are identified as artefacts, from `r length(unique(reading_session_artefacts$UserId))` different participants (`r round(length(unique(reading_session_artefacts$UserId))/(length(unique(raw_tracking_data$UserId)))*100, 2)`% of participants).

We save a copy of the reading_session_artefacts for later usage. Again, this dataset has already been saved and it can be found in the 'Data' folder.

```{r 'save-reading_session_artefacts', eval=FALSE}
# write.csv2(
#     reading_session_artefacts,
#     "reading_session_artefacts.csv"
# )
```

We then remove the reading session artefacts from the tracking data:

```{r 'remove-reading-session-artefacts'}
# merge dfs
adjusted_durations_data <- merge(
    adjusted_durations_data,
    reading_session_details[, c(1, 2, 10)],
    by = c("UserId", "ReadingSessionNumber")
)
# create new df without artefacts
artefacts_removed_tracking_data <-
    filter(
        adjusted_durations_data,
        !PotentialReadingSessionArtefact
    )
```

Removal of the artefacts reduces the number of events in the full dataset from `r nrow(adjusted_durations_data)` to `r nrow(artefacts_removed_tracking_data)`. The sample remains *n* = `r length(unique(artefacts_removed_tracking_data$UserId))`

## Add additional variables

We then calculate some additional variables that will be useful later.

* EndLocation tells us about what is the last visible character on the page (as count of characters from the beginning of the story).
* VisibleColumns indicates whether the text is divided in one or two columns. The number of columns depends on how wide the user's browser window is. Any 'WindowWidth' that is larger than 1192 pixels is shown the text in two columns, whereas smaller browser windows are shown the text in one column. See Figure 2 in the paper for the visualisation of different column set ups.

First, check that artefacts_removed_tracking_data is correctly ordered:

```{r}
# order by User, date, time and event id
artefacts_removed_tracking_data <-
    artefacts_removed_tracking_data[
        with(
            artefacts_removed_tracking_data,
            order(UserId, Date, Time, Id)
        ),
    ]
```

Then create variables:

```{r 'add-column-and-end-location-information'}
artefacts_removed_tracking_data$EndLocation <- (
    artefacts_removed_tracking_data$StartLocation +
        artefacts_removed_tracking_data$VisibleCharacterCount
)
artefacts_removed_tracking_data$VisibleColumns <- ifelse(
    artefacts_removed_tracking_data$WindowWidth > 1192,
    "TwoColumns",
    "OneColumn"
)
```

```{r 'cumulative-time-in-a-reading-session'}
# cumulative time in a reading session (RS),
## cumulative time when Engagement == "Engagement" in RS, and
### cumulative time when Engagement == "Engagement" across RSs
artefacts_removed_tracking_data <- artefacts_removed_tracking_data %>%
    group_by(UserId, ReadingSessionNumber) %>%
    mutate(
        CumulativeRSTime = cumsum(DurationMinutes),
        IsEngagement = (Engagement == "Engagement"),
        CumulativeEngagementTimeInRS = cumsum(DurationMinutes * IsEngagement)
    ) %>%
    ungroup() %>%
    group_by(UserId) %>%
    mutate(
        CumulativeEngagementTime = cumsum(DurationMinutes * IsEngagement)
    )
artefacts_removed_tracking_data <- as.data.frame(artefacts_removed_tracking_data)
```

Add information about the different books in the dataset:

```{r 'add-book-information'}
story_information_data <-
    read.csv(
        "Data/story_information_data.csv",
        header = TRUE,
        sep = ";",
        dec = ","
    )
artefacts_removed_tracking_data <- merge(
    artefacts_removed_tracking_data,
    story_information_data,
    by = "StoryId"
)
artefacts_removed_tracking_data$Percentage <- (
    artefacts_removed_tracking_data$StartLocation
        / artefacts_removed_tracking_data$CharacterLength
)
```

Look into the amount of time that each participant spent engaged in using the e-reader:

```{r 'create-summary-df-for-total-engagement-time'}
participant_engagement_time <- artefacts_removed_tracking_data %>%
    group_by(UserId) %>%
    summarise(TotalEngagedTime = max(CumulativeEngagementTime))
```

```{r 'plot-engagement-time'}
ggplot(participant_engagement_time) +
    geom_point(aes(x = UserId, y = (TotalEngagedTime / 60))) +
    labs(y = "Total engagement time in hours", x = "Participant indicator") +
    theme_classic()
```

- The x-axis of the graph shows each participant, whereas the y-axis represents total engagement time in hours. On average participants spent `r round(mean(participant_engagement_time$TotalEngagedTime), 2)` minutes using the e-reader. 

## Dataframe of grouped navigation blocks

We then create a new dataset of the tracking data in which 'navigation blocks' are grouped together.

Navigation blocks group together page navigation and page opening events (such as 'swipeForward' and 'openPage'). Consecutive events are grouped together if they reflect navigation in one direction of the text at a steady pace. This is useful for inspecting movement in the text and assigning labels for the linearity of reading. See more information on navigation blocks in the Info folder.

In the pre-processed data, events have been given a 'NavigationBlockNumber' as an indicator of whether consecutive events should be grouped together or not. Events that should be grouped together have the same NavigationBlockNumber. In addition to grouping the events, we also extract important event information that is needed for analyses, such as the duration of each navigation block. These variables are distinguished from original with NB (Navigation Block) at the beginning of the variable name.

```{r 'group-navigation-blocks'}
# turn UserId back into a factor
artefacts_removed_tracking_data$UserId <- as.factor(artefacts_removed_tracking_data$UserId)
# first create a new df
grouped_navigation_blocks_data <- artefacts_removed_tracking_data[1, ]
namevector <-
    c(
        "NBFirstStartLocation",
        "NBLastStartLocation",
        "NBFirstVisibleCharacterCount",
        "NBLastVisibleCharacterCount",
        "NBFirstReadingBlock",
        "NBLastReadingBlock",
        "NBFirstPercentage",
        "NBLastPercentage",
        "NBFirstPage",
        "NBLastPage",
        "NBFirstPagesInSection",
        "NBLastPagesInSection",
        "NBEndLocation",
        "NBAverageReadingSpeed",
        "NBFirstCumulativeRSTime",
        "NBLastCumulativeRSTime",
        "NBDuration",
        "NBSpeedLabel",
        "NBAnyProgressBarUsage",
        "NBFirstTimeBeforeDeadline",
        "NBLastTimeBeforeDeadline",
    )
grouped_navigation_blocks_data[0, namevector] <- NA
grouped_navigation_blocks_data <- grouped_navigation_blocks_data[0, ]

loopcount <- 1
# group navigation blocks into a new df
for (i in levels(artefacts_removed_tracking_data$UserId)) {
    # subset of each user
    subset_user <- subset(
        x = artefacts_removed_tracking_data,
        subset = UserId == i
    )
    subset_user$NavigationBlockNumber <-
        as.ordered(subset_user$NavigationBlockNumber)

    for (j in levels(subset_user$NavigationBlockNumber)) {
        # subset of each user's each navigation block
        subset_navigationblock <- subset(
            x = subset_user,
            subset = NavigationBlockNumber == j
        )
        subset_navigationblock <-
            subset_navigationblock[
                with(
                    subset_navigationblock,
                    order(Date, Time, Id)
                ),
            ]
        temporary_df <-
            mutate(
                subset_navigationblock,
                NBFirstStartLocation =
                    subset_navigationblock[
                        1,
                        "StartLocation"
                    ],
                NBLastStartLocation =
                    subset_navigationblock[
                        nrow(subset_navigationblock),
                        "StartLocation"
                    ],
                NBFirstVisibleCharacterCount =
                    subset_navigationblock[
                        1,
                        "VisibleCharacterCount"
                    ],
                NBLastVisibleCharacterCount =
                    subset_navigationblock[
                        nrow(subset_navigationblock),
                        "VisibleCharacterCount"
                    ],
                NBFirstReadingBlock =
                    subset_navigationblock[
                        1,
                        "ReadingBlockNumber"
                    ],
                NBLastReadingBlock =
                    subset_navigationblock[
                        nrow(subset_navigationblock),
                        "ReadingBlockNumber"
                    ],
                NBFirstPercentage =
                    subset_navigationblock[
                        1, "PercentageLocation"
                    ],
                NBLastPercentage =
                    subset_navigationblock[
                        nrow(subset_navigationblock),
                        "PercentageLocation"
                    ],
                NBFirstPage =
                    subset_navigationblock[
                        1, "PageInSection"
                    ],
                NBLastPage =
                    subset_navigationblock[
                        nrow(subset_navigationblock),
                        "PageInSection"
                    ],
                NBFirstPagesInSection =
                    subset_navigationblock[
                        1, "TotalPagesInSection"
                    ],
                NBLastPagesInSection =
                    subset_navigationblock[
                        nrow(subset_navigationblock),
                        "TotalPagesInSection"
                    ],
                NBEndLocation =
                    NBLastStartLocation + NBLastVisibleCharacterCount,
                NBAverageReadingSpeed =
                    mean(EngagedReadingSpeed),
                NBFirstCumulativeRSTime =
                    subset_navigationblock[
                        1,
                        "CumulativeRSTime"
                    ],
                NBLastCumulativeRSTime =
                    subset_navigationblock[
                        nrow(subset_navigationblock),
                        "CumulativeRSTime"
                    ],
                NBDuration =
                    subset_navigationblock[
                        nrow(subset_navigationblock),
                        "NavigationBlockDuration"
                    ],
                NBSpeedLabel =
                    subset_navigationblock[
                        nrow(subset_navigationblock),
                        "EngagedSpeedLabel"
                    ],
                NBAnyProgressBarUsage =
                    any
                    (
                        subset_navigationblock$Type == "progressBarJump"
                    ),
                NBFirstTimeBeforeDeadline =
                    subset_navigationblock[
                        1,
                        "TimeBeforeDeadlinesDays"
                    ],
                NBLastTimeBeforeDeadline =
                    subset_navigationblock[
                        nrow(subset_navigationblock),
                        "TimeBeforeDeadlinesDays"
                    ],
            )
        grouped_navigation_blocks_data <-
            rbind(grouped_navigation_blocks_data, temporary_df[1, ])
    }
    print(loopcount / length(levels(artefacts_removed_tracking_data$UserId)) * 100)
    # the loop prints % done
    loopcount <- loopcount + 1
}
```

## Save wrangled tracking data

The wrangled tracking data is saved for usage in other scripts to compute reading behaviour measures and to eventually analyse the results.
The dataset has already been saved, and so the below r code chunks are not run.

```{r 'save-wrangled-data', eval=FALSE, echo=TRUE, save wrangled data}
# write.csv2(
#     artefacts_removed_tracking_data,
#     "wrangled_tracking_data.csv"
# )
```

```{r 'save-grouped-wrangled-data', eval=FALSE, echo=TRUE}
# write.csv2(
#     grouped_navigation_blocks_data,
#     "wrangled_grouped_tracking_data.csv"
# )
```