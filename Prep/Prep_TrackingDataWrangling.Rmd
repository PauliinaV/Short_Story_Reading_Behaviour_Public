---
title: "Prep_TrackingDataWrangling"
author: "Pauliina Vuorinen"
date: "18/03/2022-"
output: html_document
library: "S1_code_library.bib"
---

## Introduction

The purpose of this script is to clean the raw reading behaviour tracking data for our analysis.

## Setup

Load libraries, set working directory

```{r, setup}
library(psych)
library(tidyverse)
library(tidyr)
library(dplyr)
getwd() # check that working directory is ~/Short_Story_Reading_Behaviour_Public
```

## Load data and check variable types

Load raw data from Data -folder and change variable types. See documents in Info -folder for information on different tracking events.

```{r, load data}
raw_tracking_data <-
    read.csv(
        "Data/preprocessed_raw_tracking_data.csv",
        header = TRUE,
        sep = ";",
        dec = ","
    )
head(raw_tracking_data)
```

```{r, change variable types}
str(raw_tracking_data)
names(raw_tracking_data)[names(raw_tracking_data) == "BookId"] <- "StoryId"
source("Functions/Functions_VariableTypeConversion.R")

## turn columns into factors that should be factors
raw_tracking_data[, c(
    "UserId",
    "StoryId",
    "Engagement",
    "EngagedSpeedLabel",
    "Direction",
    "NavigationBlockDirection"
)] <- convert.magic(
    raw_tracking_data[, c(
        "UserId",
        "StoryId",
        "Engagement",
        "EngagedSpeedLabel",
        "Direction",
        "NavigationBlockDirection"
    )],
    "factor"
)
## fix numeric columns that were automatically categorised as character
raw_tracking_data[, c(
    "BaselineSpeed",
    "AdjustedBaselineSpeed",
    "TimeBeforeDeadlinesDays",
    "TimeBeforeDeadlineMinutes",
    "DurationMinutes",
    "ReadingBlockDuration",
    "EngagedReadingDuration",
    "EngagedReadingSpeed",
    "NavigationBlockDuration"
)] <- convert.magic(
    raw_tracking_data[, c(
        "BaselineSpeed",
        "AdjustedBaselineSpeed",
        "TimeBeforeDeadlinesDays",
        "TimeBeforeDeadlineMinutes",
        "DurationMinutes",
        "ReadingBlockDuration",
        "EngagedReadingDuration",
        "EngagedReadingSpeed",
        "NavigationBlockDuration"
    )],
    "numeric"
)
## turn 'isIntrinsicCondition' into a logical variable
raw_tracking_data$IsIntrinsicCondition <-
    as.logical(
        raw_tracking_data$IsIntrinsicCondition
    )
### Create variable called 'Condition'
raw_tracking_data$Condition <-
    ifelse(raw_tracking_data$IsIntrinsicCondition == TRUE,
        "AutonomousCondition",
        "NonAutonomousCondition"
    )
## turn reading block (page view) number,
### reading session number, and
#### navigation block number into ordered factors
raw_tracking_data[, c(
    "ReadingBlockNumber",
    "ReadingSessionNumber",
    "NavigationBlockNumber"
)] <- convert.magic(
    raw_tracking_data[, c(
        "ReadingBlockNumber",
        "ReadingSessionNumber",
        "NavigationBlockNumber"
    )],
    "ordered"
)
## fix date and time variable types
raw_tracking_data$Date <-
    as.Date(
        raw_tracking_data$Date,
        format = "%d.%m.%Y"
    )
raw_tracking_data$Time <-
    gsub(
        x = raw_tracking_data$Time, ",", "."
    )
op <-
    options(digits.secs = 3)
raw_tracking_data$Time <-
    strptime(
        raw_tracking_data$Time,
        format = "%H:%M:%OS"
    )
```

```{r, order df}
# order by User, date, time and event id
raw_tracking_data <-
    raw_tracking_data[
        with(
            raw_tracking_data,
            order(UserId, Date, Time, Id)
        ),
    ]
```

## Exclusion criteria

Sixty-two participants were recruited to take part in the study. Two of the participants did not finish the study, and so they are excluded from the sample. The final *n* = 60.

```{r, exclusion}
raw_tracking_data <-
    filter(
        raw_tracking_data,
        (UserId != "33") &
            (UserId != "61")
    )
```

## Missing and erroneous data values

Fix unrealistic and misleading values in the tracking data. These errors arise from accidental miscoding during the collection of the tracking data, or alternative data formatting.

1. Change navigation block numbers (continuous navigation in one direction) recorded as zero into NA values. A navigation block number was recorded as zero if the participant was not navigating the document. This is misleading, and so zeros are turned to NAs.
```{r, fix navigation block formatting}
raw_tracking_data[, "NavigationBlockNumber"][raw_tracking_data[, "NavigationBlockNumber"] == 0] <- NA
```

2. Similarly to navigation block numbers, reading block numbers (page views) were recorded as zero when the participant was not viewing a page. This is misleading, and so zeros are turned to NAs.
```{r, fix reading block formatting}
raw_tracking_data[, "ReadingBlockNumber"][raw_tracking_data[, "ReadingBlockNumber"] == 0] <- NA
```

3. Inactive timeout events are erroneously coded as 'engagements' in the raw data. The inactive timeout indicates that the page view has been masked due to > 5mins of inactivity, and therefore, these event types should be coded as 'disengagements'.
```{r, fix inactiveTimeout engagement type}
raw_tracking_data[raw_tracking_data$Type == "inactiveTimeout", ]$Engagement <- "Disengagement"
```

### Identification of inaccurately categorised disengagements

Events were given engagement labels in the data pre-processing stage (see file __ in the Info folder for detail). A mistake in this categorisation was identified later, which showed that some e-reader system opening events were mistakenly classified as disengagements. After testing and extensive exploration of the data, these inaccurately categorised disengagements were identified by the following criteria:

1. The event is a disengagement (Engagement == "Disengagement"),
2. The event occurs during an opening event (IsOpeningEvent == TRUE) when the page has loaded (IsPageOpen == TRUE),
3. The event occurs in the e-reader (IsReading == TRUE)
4. The event occurs when disengagement-linked tests are FALSE (e.g. the text is not blurred: !IsBlurred), or
5. The event doesn't have a clear disengagement-linked event type (such as 'blur' or 'close', see more information on events in ___ in the Info folder)

```{r, inaccurately categorised disengagements}
raw_tracking_data$IsUnusualDisengagement <-
    (
        (raw_tracking_data$Engagement == "Disengagement") & #1
            (raw_tracking_data$IsOpeningEvent & #2
                raw_tracking_data$IsPageOpen) & 
            (raw_tracking_data$IsReading) & #3
                (!raw_tracking_data$IsBlurred & #4
                !raw_tracking_data$IsDialogOpen &
                !raw_tracking_data$IsMenuOpen &
                !raw_tracking_data$IsInactive) &
            (raw_tracking_data$Type != "blur" & #5
                raw_tracking_data$Type != "openMenu" &
                raw_tracking_data$Type != "inactiveTimeout" &
                raw_tracking_data$Type != "close" &
                raw_tracking_data$Type != "logout" &
                raw_tracking_data$Type != "openBook" &
                raw_tracking_data$Type != "bookDialogOpen" &
                raw_tracking_data$Type != "openInformation")
)
```

10 Unsual disengagements were found:
```{r, check unusual disengagements}
table(raw_tracking_data$IsUnusualDisengagement)
```

These events had a tendency to occur after a text masking event ('blur') and start a new reading session. The e-reader system was expecting an 'openPage' event to signify the opening of a new page, but instead the page had been loaded previously. This confusing caused the events to be categorised as disengagements rather than engagements. To fix this mistake, the 10 unusual disengagements are turned into engagements: <!-- this is a placeholder text, check with M-->

```{r, turn unusual disengagements into engagements}
raw_tracking_data$Engagement <- as.character(raw_tracking_data$Engagement)

raw_tracking_data$Engagement <- ifelse(
    raw_tracking_data$IsUnusualDisengagement,
    "Engagement",
    raw_tracking_data$Engagement
)

raw_tracking_data$Engagement <- as.factor(raw_tracking_data$Engagement)
```

### Adjustments to event and navigation block durations

Event durations are important not only because they can tell us about how long an event lasted, but 'DurationMinutes' is also used to create cumulative durations (such as 'EngagementDuration'). The event durations are calculated by deducting an event's start time from the following event's start time. Therefore, the durations of events in the middle and the beginning of a reading session are accurate as long as all events are present in the tracking data. The last event in a reading session, however, has an excessive duration because duration is miscalculated by comparing the event to the next one that is in a new reading session. This excessive duration is adjusted in two different ways, depending on whether the event is categorised as a 'disengagement' or an 'engagement'.

```{r, find last event in reading session}
# make sure the df is correctly ordered
raw_tracking_data <-
    raw_tracking_data[
        with(
            raw_tracking_data,
            order(UserId, Date, Time, Id)
        ),
    ]
# an event is the last one in a reading session if:
## the current session != next, or the current user != next
raw_tracking_data$IsLastEventInReadingSession <-
    (
        (raw_tracking_data$ReadingSessionNumber !=
            lead(raw_tracking_data$ReadingSessionNumber, 1)) |
            (raw_tracking_data$UserId !=
                lead(raw_tracking_data$UserId, 1))
    )
# last event in df assigned manually
raw_tracking_data$IsLastEventInReadingSession <-
    replace_na(raw_tracking_data$IsLastEventInReadingSession, TRUE)
```

123 of the last reading session events are disengagements and six are engagements:
```{r, check last event in reading session engagement types}
table(
    raw_tracking_data$Engagement,
    raw_tracking_data$IsLastEventInReadingSession
)
```

**Disengagements.** If the last event in a reading session is a disengagement, such as 'close' or 'logout' (see event types in info folder, document X), the duration of the event should be recorded as 0. This is because a disengagement at the end of a reading session indicates of the participants' intention to leave the e-reader system, and so its duration is arbitrary.

**Engagements.** Engagements that have a duration of >5min indicate of a missing tracking event. This can happen for a couple different reasons:

* A reading session ending in an 'engagement' indicates that the final disengagement event (triggered by the closure of the e-reader system, for example, event of type 'logout') is missing.
* In the middle of a reading session, an engagement event that has a duration of >5min is also indicative of a missing event: if an engagement event lasts for longer than 5 minutes, the data is missing a 'blur' and an 'inactiveTimeout' event from the tracking data. This is because the e-reader system automatically masks the text after 5 minutes of inactivity which triggers the 'blur' and 'inactiveTimeout' events

Missing events occur when the system doesn't have the time to record an event, for example, when the e-reader system is abruptly closed or when network connection fails. The e-reader system works on the client side, but no temporary data storage is implemented to store events collected during network connection issues and so these events are lost in case of network connection failures. <!--{this is a placeholder, need to check with M}-->

Correctly recorded engagements should last for a maximum of 5 minutes before the e-reader system masks the text. Therefore, excessive engagement durations are checked by filtering the dataset for engagements that last for longer than 5.1 minutes.

```{r, find excessive engagement durations}
excessive_engagement_durations_subdata <-
    filter(
        raw_tracking_data,
        (Engagement == "Engagement") &
            (DurationMinutes > 5.1)
    )
nrow(excessive_engagement_durations_subdata)
# only 4 cases of excessive engagement duration
```

The excessive durations are adjusted by creating new variables:
1. 'AdjustedEventDuration' shows the suggested new event duration
    * Set to 5 minutes for engagement events and to 0 for non-engagement events.
    * If an event is not the last event in a reading session or an excessive engagement duration, the event duration does not need to be adjusted and so AdjustedEventDuration = DurationMinutes

```{r, adjustments to event durations}
raw_tracking_data$AdjustedEventDuration <-
    ifelse(
        ((raw_tracking_data$Engagement == "Engagement") &
            (raw_tracking_data$DurationMinutes > 5.1)),
        5,
        ifelse(
            ((raw_tracking_data$IsLastEventInReadingSession &
                raw_tracking_data$Engagement != "Engagement")),
            0,
            raw_tracking_data$DurationMinutes
        )
    )
```

Next, we will check that AdjustedEventDuration works correctly:
```{r, check AdjustedEventDuration 1/2}
table(raw_tracking_data$DurationMinutes !=
    raw_tracking_data$AdjustedEventDuration)
```
The above code shows that 67 event durations were adjusted. Check the amount of events that we pursued to adjust:
```{r, check AdjustedEventDuration 2/2}
table(
    ( # amount of events last in a reading session that should be adjusted:
        raw_tracking_data$IsLastEventInReadingSession &
            raw_tracking_data$Engagement != "Engagement" &
            raw_tracking_data$DurationMinutes != 0
    ) | # excessive durations that should be adjusted:
        (raw_tracking_data$Engagement == "Engagement" &
            raw_tracking_data$DurationMinutes > 5.1
        )
)
```

We pursued to adjust 67 event durations with the above criteria, and we correctly adjusted these 67 events.

Next:

2. 'AdjustedNavigationBlockDuration' shows the suggested adjustment to NavigationBlockDuration
    * NavigationBlockDuration sums together the durations of all events that belong in the same navigation block (events that include navigation in the same direction)
    * NavigationBlockDuration is therefore influenced by the error in event durations. We adjust navigation block duration by summing AdjustedEventDuration for each UserId and each NavigationBlockNumber

```{r, adjust navigation block durations}
adjusted_navigationblock_duration <- raw_tracking_data %>%
    group_by(UserId, NavigationBlockNumber) %>%
    summarise(
        AdjustedNavigationBlockDuration =
            sum(AdjustedEventDuration)
    )
raw_tracking_data <-
    merge(
        raw_tracking_data,
        adjusted_navigationblock_duration,
        by = c("UserId", "NavigationBlockNumber")
    )
```

Finally, create a new dataframe without unadjusted event duration and navigation block duration to avoid confusion.

```{r, remove unadjusted durations}
adjusted_durations_data <- raw_tracking_data %>%
    select(-DurationMinutes, -NavigationBlockDuration)
```

### Reading session artefacts

The data analysis for the current study was focused on engaged reading, and so very short reading sessions or sessions that only consist of disengagement events were not considered to be meaningful. Reading sessions with little reading may have occurred when participants attempted to resume a reading session but became quickly distracted by other things, or if they accidentally opened the browser tab with the e-reader.

We expected an intentional reading session to be captured by the following criteria:

1. Reading sessions should last more than a minute,
2. Less than 95% of the reading session duration should be disengagement events,

To ensure that this threshold was meaningful and did not remove any reading sessions of interest, we identified potential reading session artefacts with this threshold and compared them to visualisations of each participants' reading sessions (see timeline figures in folder Figu). The comparison showed that these two criteria could be used to identify most of the reading sessions that seemed to consist of little reading. Additional testing showed that some of the remaining reading sessions mostly consisted of a combination of disengagements and 'dialog' -events (dialog events refer to the opening of the menu), and so a third criteria was added:

3. Less than 80% of the reading session duration should be disengagement and dialog events.

Comparison to the visualisations indicated that these three criteria were sufficient in detecting reading session artefacts.

```{r, identify reading session artefacts}
# prepare a new df
UserList <- levels(adjusted_durations_data$UserId)
SessionDetails <- data.frame(
    UserId = factor(),
    ReadingSessionNumber = numeric(),
    SessionLength = numeric(),
    DisengagementDuration = numeric(),
    DialogDuration = numeric(),
    SlowReadingDuration = numeric(),
    EngagementProportion = numeric(),
    DisengagementProportion = numeric(),
    DialogAndDisengagementProportion = numeric()
)
firstrow <- 1
adjusted_durations_data$ReadingSessionNumber <-
    as.numeric(
        as.character(
            adjusted_durations_data$ReadingSessionNumber
        )
    )

# calculate session details to the new df
for (user in UserList) {
    subset_df1 <- filter(adjusted_durations_data, UserId == user)
    for (session in unique(subset_df1$ReadingSessionNumber)) {
        subset_df2 <- filter(subset_df1, ReadingSessionNumber == session)
        temporary_df <- subset_df2 %>%
            summarise(
                SessionLength =
                    sum(AdjustedEventDuration, na.rm = TRUE),
                DisengagementDuration =
                    sum(
                        subset_df2[subset_df2$Engagement == "Disengagement", ]$AdjustedEventDuration,
                        na.rm = TRUE
                    ),
                DialogDuration =
                    sum(
                        subset_df2[subset_df2$Engagement == "Dialog", ]$AdjustedEventDuration,
                        na.rm = TRUE
                    ),
                SlowReadingDuration =
                    sum(
                        subset_df2[subset_df2$NavBlockSpeedLabel == "SlowReading", ]$AdjustedEventDuration,
                        na.rm = TRUE
                    ),
                EngagementProportion =
                    (
                        sum(
                            subset_df2[subset_df2$Engagement == "Engagement", ]$AdjustedEventDuration,
                            na.rm = TRUE
                        )
                        / SessionLength
                    ),
                DisengagementProportion =
                    (DisengagementDuration / SessionLength),
                DialogAndDisengagementProportion =
                    ((DisengagementDuration + DialogDuration) / SessionLength)
            )
        temporary_df$UserId <- user
        temporary_df$ReadingSessionNumber <- session
        rows <- nrow(temporary_df)
        SessionDetails <- bind_rows(SessionDetails, temporary_df)
        firstrow <- firstrow + rows
    }
}

# identify potential reading session artefacts based on criteria
SessionDetails$PotentialReadingSessionArtefact <-
    ifelse(
        ((SessionDetails$SessionLength < 1) | #criteria 2
            (SessionDetails$DisengagementProportion > 0.95) | # criteria 1
            (SessionDetails$DialogAndDisengagementProportion > 0.8)), # criteria 3
        TRUE,
        FALSE
    )
```

In total 32 reading session are identified as artefacts, from 11 different participants.
```{r, check artefacts}
Artefacts <-
    filter(
        SessionDetails,
        PotentialReadingSessionArtefact
    )
nrow(Artefacts)
table(Artefacts$UserId)
```

Remove reading session artefacts and create a new df:
```{r, remove reading session artefacts}
# merge dfs
adjusted_durations_data <- merge(
    adjusted_durations_data,
    SessionDetails[, c(1,2,10)],
    by = c("UserId", "ReadingSessionNumber")
)

# create new df without artefacts
tracking_data_artefacts_removed <-
    filter(
        adjusted_durations_data,
        !PotentialReadingSessionArtefact
    )

# order the new df
tracking_data_artefacts_removed <-
    tracking_data_artefacts_removed[with(tracking_data_artefacts_removed, order(UserId, Date, Time, Id)), ]
```

## Cumulative time in a reading session

Add a variable in the dataframe that tells us the cumulative time in a reading session for each event.

```{r, add cumulative time}
tracking_data_artefacts_removed <-
    tracking_data_artefacts_removed %>%
    group_by(UserId, ReadingSessionNumber) %>%
    mutate(
        CumReadingSessionTime = cumsum(AdjustedEventDuration)
    )
```


## Save wrangled tracking data

The wrangled tracking data is saved for usage in other scripts to compute reading behaviour measures and to eventually analyse the results.
The dataset has already been saved, and so the below r code chunk is not run.

```{r, eval=FALSE, echo=TRUE, save wrangled data}
write.csv2(tracking_data_artefacts_removed,
    "wrangled_tracking_data.csv"#,
    header = TRUE,
    dec = ",",
    sep = ";"
)
```